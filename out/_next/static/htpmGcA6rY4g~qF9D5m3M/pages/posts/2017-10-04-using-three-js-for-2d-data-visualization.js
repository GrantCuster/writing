(window.webpackJsonp=window.webpackJsonp||[]).push([["fded"],{bdZk:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/posts/2017-10-04-using-three-js-for-2d-data-visualization",function(){var e=n("g18Y");return{page:e.default||e}}])},g18Y:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",function(){return r}),n.d(t,"default",function(){return l});var a=n("kOwS"),o=n("qNsG"),i=(n("q1tI"),n("E/Ix")),r={layout:"post",title:"First Look: Using Three.js for 2D Data Visualization",date:"2017-10-04 10:30",preview_image:"http://blog.fastforwardlabs.com/images/2017/10/tsne-final.png",author:"Grant",author_link:"https://twitter.com/GrantCuster"},s={frontMatter:r},h="wrapper";function l(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)(h,Object(a.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h5",null,"Update: I have a new post on ",Object(i.b)("a",Object(a.a)({parentName:"h5"},{href:"https://beta.observablehq.com/@grantcuster/using-three-js-for-2d-data-visualization"}),"Using three.js for 2D data visualization"),". It contains all the stuff I learned while working on the project and is the place you should look for updated code. This post may still be interesting if you want to see my thoughts when I first started on the project."),Object(i.b)("p",null,"We've started work on our next prototype. While the design is still\nevolving, we're pretty sure one element of it will be a visualization of tens of\nthousands of data points, clustered through a dimensional reduction algorithm\n(most likely using\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding"}),"T-SNE"),").\nFor the past week I've been exploring how to render that many points in the\nbrowser and I\nwanted to document some early lessons in this post, specifically about using the\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://threejs.org/"}),"three.js")," library."),Object(i.b)("p",null,"I'm new to three.js so this isn't a best practices post. Hopefully this provides a\nstarting point for people interested in doing similar data visualization work.\nIf you have ideas on how to do this stuff better, I'd love to hear them via\nTwitter (",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"//www.twitter.com/GrantCuster"}),"@grantcuster"),")."),Object(i.b)("h2",null,"What I'm after"),Object(i.b)("p",null,Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"/images/2017/10/tsne-final.png",alt:"A screenshot of the final working demo: a plotted t-sne with working pan and zoom."}))),Object(i.b)("h5",null,"The final result: ",Object(i.b)("a",Object(a.a)({parentName:"h5"},{href:"https://codepen.io/GrantCuster/pen/rGGRRp"}),"a T-SNE rendered in three.js with a map style pan and zoom"),"."),Object(i.b)("p",null,"I want to render a visualization with tens of thousands of points. I want to be\nable to zoom into that visualization by scrolling and pan by clicking and\ndragging (think ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"//maps.google.com"}),"Google Maps"),"). I want the zoom to follow the\nposition of the mouse and I want that zoom to feel smooth and responsive. I also want the browser to not crash when I do those things."),Object(i.b)("h2",null,"Challenges"),Object(i.b)("p",null,"The main challenge has been getting a good zoom feel. For me, zoom feels bad\nwhen:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"The framerate drops because the browser can't handle rendering that many points."),Object(i.b)("li",{parentName:"ol"},"The zoom behavior is too fast, or jerky.")),Object(i.b)("p",null,"The solution to #1 is to use three.js. The solution to #2 (so far) is to use\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/d3/d3-zoom"}),"D3.js's zoom behavior")," combined with three.js.\nMore detail on both below."),Object(i.b)("h2",null,"Rendering strategies"),Object(i.b)("p",null,"There are three strategies I considered for visualizing a bunch of\npoints on the web:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://bl.ocks.org/mbostock/4e3925cdc804db257a86fdef3a032a45"}),"D3.js rendering to SVG")),Object(i.b)("li",{parentName:"ol"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://bl.ocks.org/mbostock/b418a040bb28295e4a78581fe8e269d1"}),"D3.js rendering to canvas (better performance)")),Object(i.b)("li",{parentName:"ol"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://codepen.io/GrantCuster/pen/QqvXwd"}),"Three.js rendering to canvas with webGL (best performance when rendering lots of points)"))),Object(i.b)("p",null,"Most D3 examples use SVG, but there are canvas examples for when you are\nanimating lots of points and need the boosted performance. I didn't find any\nthree.js-specific examples so I made my own. I'd love to see an\nexhaustive investigation and benchmark for the performance of each (and\nalternative methods!), but I'm not going to do that here."),Object(i.b)("h2",null,"Prior art and past experience"),Object(i.b)("p",null,"I'd had my own experience with the limits of SVG rendering for lots of points.\nI'd also seen a bit of what WebGL could do while working on our ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"http://fastforwardlabs.github.io/pre"}),"Probabilistic Real\nEstate prototype"),", which uses ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.mapbox.com/mapbox-gl-js/api/"}),"Mapbox's\nWebGL library"),". For knowledge of\ncanvas and three.js strategies, I was lucky to have the examples of two great\npast projects from FFL interns."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"//www.twitter.com/whaleandpetnuia"}),"Aditya")," used D3 rendered to canvas in his\n",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"http://fastforwardlabs.github.io/cinephile_tsne/"}),"visualization of a community's taste in\nmovies"),". I watched him push\ncanvas rendering to its limits, rendering around 20,000 points."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"//sepans.com/"}),"Sepand")," used three.js to render his ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"//www.fastforwardlabs.com/encartopedia"}),"visualization\nof Wikipedia articles"),". He was able to\nrender 100,000 points without framerate issues. Coming (like me) from D3\nexperience, he had to invest considerable dev time in understanding\nthree.js's camera system.")),Object(i.b)("p",null,"Based on those experiences, I went into this project thinking I'd use three.js. It also just\nseemed like fun. Three.js comes more out of the game dev world\nthan the web app one I'm used to. A lot of recent web app\ninnovation has come from adopting techniques from the video game world, so I was\nexcited about the opportunity to further explore that path."),Object(i.b)("h2",null,"Getting started in three.js"),Object(i.b)("p",null,"I looked through the three.js ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://threejs.org/docs/index.html#manual/introduction/Creating-a-scene"}),"documentation")," and ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://threejs.org/examples/"}),"examples"),". Then I started looking\nfor examples of 2D visualizations that were similar to what I wanted to create. There are\nnot many. I did find this ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://stackoverflow.com/questions/21786184/setting-up-a-2d-view-in-three-js"}),"Stack Overflow post about setting up a 2D\nview"),",\nwhich had some helpful points for getting started and an encouraging tone (I\nlove that by the third update they're reading ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.amazon.com/dp/0321399528/"}),"Computer Graphics and Principles"),")."),Object(i.b)("h3",null,"Setting the scene"),Object(i.b)("p",null,"I started with the basic scene set-up from the three.js\ntutorial, and worked on replacing the spinning cube with a wall of points. I put\nsome work into trying to understand the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://threejs.org/docs/#api/cameras/PerspectiveCamera"}),"PerspectiveCamera"),", but in terms of getting\nthings to render at the size I was after I mainly used trial and error of\nplugging in different parameters. One of the downsides of rendering to a canvas\n(rather than HTML or SVG) is that you don't have a DOM to inspect for debugging.\nOften I'd find myself with a blank canvas and I'd have to retrace my steps to a\npoint where things were working. I made frequent reference to ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/sepans/wikiviz"}),"Sepand's\ncode"),"."),Object(i.b)("h3",null,"The animation loop"),Object(i.b)("p",null,"One of the video game techniques you use in three.js is the animation loop:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"// Three.js render loop\nfunction animate() {\n  requestAnimationFrame(animate)\n  renderer.render(scene, camera)\n}\nanimate()\n")),Object(i.b)("p",null,"Rather than having logic set up to only re-draw when things change, the animation\nloop is always re-drawing. Because of this, you don't have to worry about render\nlogic as you update objects (like the camera) in a three.js scene. You just\nupdate them. This resonates with the philosophy of newer javascript frameworks like\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/"}),"React"),". I don't know the exact paths of influence there (I would be interested to\nread them!) but it's fun for me to discover connections as I go."),Object(i.b)("h3",null,"Z-Fighting"),Object(i.b)("p",null,Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"/images/2017/10/z-fighting.png",alt:"A screenshot of the flickering points debug demo."}))),Object(i.b)("h5",null,"An early challenge: ",Object(i.b)("a",Object(a.a)({parentName:"h5"},{href:"https://codepen.io/GrantCuster/pen/GMmPxx"}),"flickering caused by z-fighting")),Object(i.b)("p",null,"After I got a lot of points to render at the size I wanted, I found that some of the\npoints would flicker. I eventually learned this flickering was caused by\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Z-fighting"}),"z-fighting"),", where, because they were\nall on the same z-level, different points were 'winning' each time the scene was\ndrawn. It sounds like there is some combination of camera properties that could\nsolve the issue, but I was unable to find the right combo. As pointed out in the\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://stackoverflow.com/questions/21786184/setting-up-a-2d-view-in-three-js"}),"above-mentioned Stack Overflow\npost"),",\nyou may also be able to fix it by slightly varying the z-value of each point. If\nit came to it I would do that, but it didn't feel right."),Object(i.b)("p",null,"I ended up solving the problem by setting ",Object(i.b)("inlineCode",{parentName:"p"},"sizeAttenuation: false")," on the\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://threejs.org/docs/#api/materials/PointsMaterial"}),"PointsMaterial"),". In its default state of ",Object(i.b)("inlineCode",{parentName:"p"},"true"),", ",Object(i.b)("inlineCode",{parentName:"p"},"sizeAttenuation")," scales the\npoints so they appear larger as you get closer and smaller as you move the camera\nfarther away. Attenuation makes sense as a simulation of real objects, but\nfor a visualization, setting it to ",Object(i.b)("inlineCode",{parentName:"p"},"false"),", which means the points stay the same\nsize regardless of zoom level, is often more desirable. Unattenuated means that as you zoom in, the negative space between points\nexpands. For dense visualizations, this lets you see local structure better as\nyou zoom in. I'm not sure why turning off ",Object(i.b)("inlineCode",{parentName:"p"},"sizeAttenuation")," fixed the z-fighting issue, but since I wanted it off anyway, I closed\nthe case."),Object(i.b)("h2",null,"Zoom and pan"),Object(i.b)("p",null,"Getting the points on the screen went fairly smoothly. Dialing in a zoom and pan\nset-up that I'm happy with was more of a process. Targeted\nzoom requires an understanding of the camera and perspective that I'm still\ndeveloping."),Object(i.b)("h3",null,"Handling mouse events"),Object(i.b)("p",null,"First I needed to translate mouse events into zoom and pan actions. I started by\ntrying to plug in ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/d3/d3-zoom"}),"D3's zoom behavior"),", since I was most familiar with it, and I\ndidn't want to do the low-level event work of calculating how far a user\nscrolled. The zoom behavior gets you a scale level, and an ",Object(i.b)("inlineCode",{parentName:"p"},"x")," and ",Object(i.b)("inlineCode",{parentName:"p"},"y")," value.\nCombined in a transform, they get you the sort of directed zoom I was after. But I ended up\nusing only the scale level from it because I could not figure out how to translate\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"x")," and ",Object(i.b)("inlineCode",{parentName:"p"},"y")," coordinates into the correct three.js camera\nposition. I'm 90% sure it's doable, but I didn't figure it out this round."),Object(i.b)("h3",null,"Directed zoom"),Object(i.b)("p",null,"I had a hard time finding an example of the zoom behavior I wanted implemented\nin three.js. Even Google's impressive ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"http://projector.tensorflow.org/"}),"Embedding\nProjector")," zooms to the center of the screen\nrather than following the mouse position. I thought that if I could figure out\nhow to translate the mouse position on screen along different z-values,\nI could figure something out myself. That question turns out to be a\nrelatively well-explored one because people often need it to calculate hover\ninteractions with objects."),Object(i.b)("p",null,"This ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://stackoverflow.com/questions/13055214/mouse-canvas-x-y-to-three-js-world-x-y-z/13091694#13091694"}),"code snippet from\nWestLangley")," turned out to be the key for getting\ndirected zoom working:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"var vector = new THREE.Vector3()\n\nvector.set(\n  (event.clientX / window.innerWidth) * 2 - 1,\n  -(event.clientY / window.innerHeight) * 2 + 1,\n  0.5\n)\n\nvector.unproject(camera)\n\nvar dir = vector.sub(camera.position).normalize()\n\nvar distance = -camera.position.z / dir.z\n\nvar pos = camera.position.clone().add(dir.multiplyScalar(distance))\n")),Object(i.b)("p",null,"It projects a ray from the camera through the mouse position. You can then\nmove along that ray on the z-axis, using the ",Object(i.b)("inlineCode",{parentName:"p"},"z")," value to get back new ",Object(i.b)("inlineCode",{parentName:"p"},"x")," and\n",Object(i.b)("inlineCode",{parentName:"p"},"y")," coordinates. In ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://codepen.io/GrantCuster/pen/rGGRRp"}),"my code"),", I'm taking the scale from D3's zoom behavior and\nplugging it in as the new ",Object(i.b)("inlineCode",{parentName:"p"},"z")," value. I can then use the ",Object(i.b)("inlineCode",{parentName:"p"},"x")," and ",Object(i.b)("inlineCode",{parentName:"p"},"y")," values to set the\nnew camera position and get the directed zoom effect I was after. My\nunderstanding of ",Object(i.b)("em",{parentName:"p"},"exactly")," what's happening here is still fuzzy, I tried\ndissecting it a bit and hope to do more in the future. For now, though, it\nworks."),Object(i.b)("h3",null,"Crashing"),Object(i.b)("p",null,"I crashed my browser a lot during the zoom experiments, and sometimes even crashed my\ncomputer especially when I started trying to ",Object(i.b)("inlineCode",{parentName:"p"},"console.log")," to debug on zoom\nevents. I don't have any real insight into what was causing the crash. I tried\nsome developer tools profiling, but I wasn't really sure what to look for. Compared\nto an error message, a crash is a real bummer to recover from, and it's a big\nreason I didn't dissect the zoom code further. The cost of a mistake was too\nhigh. This was compounded because I don't really have a sense yet of what is\nexpensive for three.js/3D in general and what is not. I kept stumbling into\ncrashes while changing something I thought was innocuous. The whole experience made me less\nlikely to experiment with changing things that were working, which is a big part\nof how I learn how things work. I don't know if there's anything to be done at a\nlibrary or browser level that would result in more error messages and fewer\ncrashes, but it would be a big help for getting started."),Object(i.b)("h3",null,"Panning"),Object(i.b)("p",null,"While looking for a panning solution, I found ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/anvaka/three.map.control"}),"Andrei Kashcha's\nthree.map.control"),",\nwhich conceptually had the things I was after for both directed zoom and\npanning. I did not like the zoom feel, however. In my opinion it moves\ntoo fast and the thresholding makes it jerky. The momentum setting on the\npanning is also not what I was after."),Object(i.b)("p",null,"I checked out the code, and found the ",Object(i.b)("inlineCode",{parentName:"p"},"getCurrentScale"),"\nfunction which calculates the current scale based on the camera settings and ",Object(i.b)("inlineCode",{parentName:"p"},"z"),"\nvalue. Using this along with the ",Object(i.b)("inlineCode",{parentName:"p"},"movementX")," and ",Object(i.b)("inlineCode",{parentName:"p"},"movementY")," events from D3's\nzoom behavior (how\nfar you'd dragged) yielded the pan behavior I was after."),Object(i.b)("p",null,"I experimented with using ",Object(i.b)("inlineCode",{parentName:"p"},"getCurrentScale")," to replace the ray function I was using for zoom.\nIt seemed cleaner to have the directed zoom and panning operating off the same\nlogic. After a fair amount of experimenting I got values fairly close to the ray\nmethod – but not close enough. It felt like I was zooming on ice. I'm\nstill 90% sure can be done, but after crashing the browser a bunch\nof times trying to figure it out, I decided to stick with the current working\nconfiguration."),Object(i.b)("h2",null,"A practical success"),Object(i.b)("p",null,"So, after lots of experimentation, crashes, and help from other people's code,\nI made it to ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://codepen.io/GrantCuster/pen/rGGRRp"}),"a working example with tens of thousands of\npoints, and the zoom and panning behavior I was\nafter"),". I'd like to tighten up the\ncode for that behavior as well as my understanding of it, but that's\nalways the case. I've had my first tangle with a lot of the concepts and edges\nof three.js, and I expect I'll have lots of opportunities to revisit them. I look\nforward to learning how to do all of this stuff better in the future."),Object(i.b)("h2",null,"Notes"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"In the current demo the zoom direction is inverted because I'm plugging D3's\nscale directly into the camera's z-value. D3 evidently has some easing as you\nzoom in close, where it slows down the rate of zoom change. That means I can't\njust simply invert the scale. I'll figure out something to fix this in the\nfuture."),Object(i.b)("li",{parentName:"ul"},"In the demo, I scale the point size up a bit when you're really close. This is\nwhat feels best to me -- points stay the same size most of the way in, but at\nthe end they get a bit bigger. Right now it's all an experiment in what feels right."),Object(i.b)("li",{parentName:"ul"},"Why exactly is three.js fast? This is something I'd love to learn more about.\nMy operating understanding is that WebGL uses the GPU, which is good at doing\nthese kinds of calculations, and three.js is also very smart about only drawing\nwhat you can currently see (known as culling). I don't know how this all plays\nout though. Is it fast mostly because of the GPU use or mostly because of the\nculling?"),Object(i.b)("li",{parentName:"ul"},"The camera uses a field of view setting which is not at all intuitive to me, but if you\nhave friends or coworkers who are into actual physical cameras they'll have a\nbunch of experience with it. You can ask them about it and they'll probably draw\ndiagrams."),Object(i.b)("li",{parentName:"ul"},"Why am I using a 3D library for a 2D visualization? Because it's fast. I did\nlook at the 2D WebGL renderer ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"http://www.pixijs.com/"}),"PixiJS")," but found mostly\ngame related examples. I could also try using the WebGL library directly. I'd\nlove to read about either of those approaches. But given my time limit three.js\nseemed the right level at which to dive in."),Object(i.b)("li",{parentName:"ul"},"Why are the points squares? It is apparently more taxing to draw circles.\nSepand did it, and I plan to eventually (with sprites) once I understand the\nins-and-outs a little more.")))}l.isMDXComponent=!0}},[["bdZk","5d41","9da1"]]]);